import os          # Pour les opérations sur les fichiers et chemins
import sys         # Pour les opérations système
import psutil      # Pour gérer les processus
import winreg      # Pour manipuler le registre Windows
import socket      # Pour les connexions réseau
import subprocess  # Pour exécuter des commandes système
import time        # Pour les opérations temporelles
from datetime import datetime  # Pour horodater le rapport
import ctypes      # Pour vérifier les droits admin
import wmi         # Pour accéder aux informations Windows

class FynloskiHunter:
    def __init__(self):
        """Initialisation avec les signatures mises à jour"""
        if not self.is_admin():
            print("Ce programme nécessite des droits administrateur!")
            sys.exit(1)
            
        self.malware_name = "maltrack.exe"  # Nom connu du malware
        self.malware_folder = "maltrack"    # Dossier connu du malware
        self.suspected_ports = [1604, 1605, 1606, 1010, 49377]
        self.documents_path = os.path.join(os.environ['USERPROFILE'], 'Documents')

    def is_admin(self):
        """Vérifie les droits administrateur"""
        try:
            return ctypes.windll.shell32.IsUserAnAdmin()
        except:
            return False

    def scan_processes(self):
        """Détecte et termine les processus malveillants"""
        print("\n[*] Recherche des processus malveillants...")
        found_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if self.malware_name.lower() in proc.info['name'].lower():
                    found_processes.append(proc)
                    print("[!] Processus malveillant trouvé: {} (PID: {})".format(
                        proc.info['name'], proc.info['pid']))
                    proc.kill()
                    print("[+] Processus {} terminé".format(proc.info['pid']))
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        return found_processes

    def clean_registry_run_keys(self):
        """Nettoie les clés Run du registre"""
        print("\n[*] Nettoyage des clés de registre Run...")
        
        run_keys = [
            (winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Run"),
            (winreg.HKEY_LOCAL_MACHINE, r"Software\Microsoft\Windows\CurrentVersion\Run")
        ]
        
        for hkey, key_path in run_keys:
            try:
                key = winreg.OpenKey(hkey, key_path, 0, winreg.KEY_ALL_ACCESS)
                i = 0
                while True:
                    try:
                        name, value, _ = winreg.EnumValue(key, i)
                        if self.malware_name.lower() in value.lower():
                            winreg.DeleteValue(key, name)
                            print("[+] Entrée supprimée de {}: {}".format(key_path, name))
                    except WindowsError:
                        break
                    i += 1
                winreg.CloseKey(key)
            except WindowsError:
                continue

    def clean_winlogon_userinit(self):
        try:
            # Accéder à la clé de registre Userinit
            reg_path = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path, 0, winreg.KEY_READ | winreg.KEY_WRITE)
            
            # Lire la valeur brute de Userinit
            value, value_type = winreg.QueryValueEx(key, "Userinit")
            
            # Afficher la valeur brute pour débogage
            print("Valeur brute de Userinit : {}".format(value))
            
            # Assurez-vous que la valeur est bien une chaîne
            if isinstance(value, str):
                # Séparer les chemins par des virgules
                paths = [path.strip() for path in value.split(",")]

                # Chemin attendu
                expected_path = r"C:\Windows\system32\userinit.exe"

                # Filtrer les chemins pour ne conserver que le chemin attendu
                filtered_paths = [expected_path] if expected_path in paths else []

                # Vérifier s'il y a des changements nécessaires
                if set(paths) != set(filtered_paths):
                    # Réécrire la clé avec uniquement le chemin attendu
                    winreg.SetValueEx(key, "Userinit", 0, value_type, ",".join(filtered_paths))
                    print("Clé Userinit nettoyée : {}".format(filtered_paths))
                else:
                    print("Aucune modification nécessaire. La clé Userinit est déjà propre.")
            else:
                print("La valeur Userinit n'est pas une chaîne valide.")

            winreg.CloseKey(key)

        except FileNotFoundError:
            print("La clé Userinit n'existe pas dans le registre.")
        except PermissionError:
            print("Permission refusée. Essayez d'exécuter le script avec des privilèges administratifs.")
        except Exception as e:
            print("Une erreur s'est produite : {}".format(e))
        

    def remove_malware_files(self):
        """Supprime les fichiers du malware"""
        print("\n[*] Suppression des fichiers malveillants...")
        
        malware_path = os.path.join(self.documents_path, self.malware_folder)
        if os.path.exists(malware_path):
            try:
                for root, dirs, files in os.walk(malware_path):
                    for file in files:
                        full_path = os.path.join(root, file)
                        try:
                            os.remove(full_path)
                            print("[+] Fichier supprimé : {}".format(full_path))
                        except:
                            print("[!] Impossible de supprimer : {}".format(full_path))
                
                os.rmdir(malware_path)
                print("[+] Dossier supprimé : {}".format(malware_path))
            except Exception as e:
                print("[!] Erreur lors de la suppression : {}".format(str(e)))

    def find_attacker_ip(self):
        """Trouve l'IP de l'attaquant en vérifiant les connexions"""
        print("\n[*] Recherche des connexions suspectes...")
        
        # Vérifie toutes les connexions, pas seulement les ESTABLISHED
        for conn in psutil.net_connections(kind='inet'):
            if conn.raddr:  # Si une adresse distante existe
                ip, port = conn.raddr
                # Ajout de l'état de la connexion dans le log
                print("[*] Connexion trouvée : {}:{} -> {}:{} ({})".format(
                    conn.laddr[0], conn.laddr[1], ip, port, conn.status
                ))
                
                # On vérifie spécifiquement le port 1010 et l'état SYN_SENT
                if port == 1010 and conn.status == 'SYN_SENT':
                    print("[!] Connexion suspecte identifiée : {}:{}".format(ip, port))
                    return ip
        
        return None


    def generate_report(self, processes, attacker_ip):
        """Génère un rapport détaillé"""
        report = """
=== Rapport de nettoyage Fynloski ===
Date: {}

1. Processus malveillants détectés et terminés:
""".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'))

        if processes:
            for proc in processes:
                report += "- {} (PID: {})\n".format(proc.info['name'], proc.info['pid'])
        else:
            report += "Aucun processus malveillant détecté\n"

        report += "\n2. IP de l'attaquant:\n"
        if attacker_ip:
            report += "- {}\n".format(attacker_ip)
        else:
            report += "Aucune IP suspecte détectée\n"

        with open('fynloski_report.txt', 'w') as f:
            f.write(report)
        print("\n[+] Rapport sauvegardé dans 'fynloski_report.txt'")

    def clean_system(self):
        """Procédure complète de nettoyage"""
        print("\n=== Début du nettoyage du système ===\n")
        
        # 1. Trouve l'IP de l'attaquant avant de tuer les processus
        attacker_ip = self.find_attacker_ip()
        
        # 2. Termine les processus malveillants
        infected_processes = self.scan_processes()
        
        # 3. Nettoie les entrées de registre
        self.clean_registry_run_keys()
        
        # 4. Nettoie Winlogon Userinit
        self.clean_winlogon_userinit()
        
        # 5. Supprime les fichiers
        self.remove_malware_files()
        
        # 6. Génère le rapport
        self.generate_report(infected_processes, attacker_ip)
        
        print("\n=== Nettoyage terminé ===")

def main():
    try:
        hunter = FynloskiHunter()
        hunter.clean_system()
    except Exception as e:
        print("\n[!] Erreur: {}".format(str(e)))
        sys.exit(1)

if __name__ == "__main__":
    main()