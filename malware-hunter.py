import psutil
import winreg
import subprocess
import socket
import os
import hashlib
import re
from datetime import datetime
import wmi
import threading
import time

class AdvancedMalwareHunter:
    def __init__(self):
        self.suspicious_processes = []
        self.suspicious_connections = []
        self.startup_entries = []
        self.malicious_files = []
        self.attacker_ips = set()
        
        # Signatures spécifiques à Fynloski/DarkComet
        self.fynloski_signatures = {
            'process_names': ['dcrat', 'darkcomet', 'dc_server'],
            'registry_keys': [
                r'SOFTWARE\DarkComet',
                r'SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
            ],
            'file_patterns': [
                r'dc_config\.txt$',
                r'dark\.txt$',
                r'\.dc$'
            ],
            'network_patterns': [
                1604,  # Port par défaut de DarkComet
                1605,
                1606
            ]
        }
        
        self.c2_domains = set()  # Stockage des domaines C2 détectés
        
    def calculate_file_hash(self, filepath):
        """Calcule le hash SHA-256 d'un fichier"""
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except:
            return None

    def scan_memory_patterns(self):
        """Recherche des patterns connus de Fynloski dans la mémoire des processus"""
        print("[+] Scanning memory patterns...")
        
        patterns = [
            rb"DarkComet",
            rb"DC_STUB",
            rb"#KCMDDC",
            rb"SERVER_INFO"
        ]
        
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                # Lecture de la mémoire du processus
                with open(f"/proc/{proc.pid}/mem", "rb") as f:
                    mem_content = f.read()
                    for pattern in patterns:
                        if pattern in mem_content:
                            self.suspicious_processes.append({
                                'pid': proc.pid,
                                'name': proc.name(),
                                'reason': f"Memory pattern found: {pattern}"
                            })
            except:
                continue

    def monitor_network_traffic(self):
        """Surveille le trafic réseau suspect en temps réel"""
        print("[+] Monitoring network traffic...")
        
        def check_connection(conn):
            """Vérifie si une connexion est suspecte"""
            if conn.status == 'ESTABLISHED':
                remote_ip = conn.raddr.ip
                remote_port = conn.raddr.port
                
                # Vérification des ports connus
                if remote_port in self.fynloski_signatures['network_patterns']:
                    self.attacker_ips.add(remote_ip)
                    return True
                    
                # Vérification des connexions persistantes
                if conn.status == 'ESTABLISHED' and conn.duration > 3600:  # Plus d'une heure
                    self.suspicious_connections.append({
                        'ip': remote_ip,
                        'port': remote_port,
                        'duration': conn.duration,
                        'reason': 'Long-lasting connection'
                    })
                    
        for proc in psutil.process_iter(['pid', 'name', 'connections']):
            try:
                for conn in proc.connections():
                    check_connection(conn)
            except:
                continue

    def clean_infection(self):
        """Nettoie une infection Fynloski détectée"""
        print("[+] Starting infection cleanup...")
        
        # 1. Tuer les processus suspects
        for proc in self.suspicious_processes:
            try:
                p = psutil.Process(proc['pid'])
                p.terminate()
                print(f"[+] Terminated process: {proc['name']} (PID: {proc['pid']})")
            except:
                continue

        # 2. Supprimer les entrées de registre
        for reg_key in self.fynloski_signatures['registry_keys']:
            try:
                subprocess.run(['reg', 'delete', reg_key, '/f'], capture_output=True)
                print(f"[+] Removed registry key: {reg_key}")
            except:
                continue

        # 3. Supprimer les fichiers malveillants
        for file in self.malicious_files:
            try:
                os.remove(file['path'])
                print(f"[+] Removed file: {file['path']}")
            except:
                continue

        # 4. Bloquer les IPs des attaquants
        for ip in self.attacker_ips:
            try:
                subprocess.run(['netsh', 'advfirewall', 'firewall', 'add', 'rule',
                              f'name="Block {ip}"', 'dir=out', 'action=block',
                              f'remoteip={ip}'], capture_output=True)
                print(f"[+] Blocked attacker IP: {ip}")
            except:
                continue

    def deep_scan(self):
        """Effectue un scan approfondi du système"""
        print("\n=== Starting Deep System Scan ===\n")
        
        # Lancer les scans en parallèle
        threads = [
            threading.Thread(target=self.scan_memory_patterns),
            threading.Thread(target=self.monitor_network_traffic),
            threading.Thread(target=self.check_startup)
        ]
        
        for thread in threads:
            thread.start()
            
        for thread in threads:
            thread.join()
            
        # Générer et retourner le rapport
        return self.generate_detailed_report()

    def generate_detailed_report(self):
        """Génère un rapport détaillé de l'analyse"""
        report = f"""
=== Advanced Malware Analysis Report ===
Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

1. Suspicious Processes
{'-' * 50}"""
        
        for proc in self.suspicious_processes:
            report += f"\nProcess: {proc['name']} (PID: {proc['pid']})"
            report += f"\nReason: {proc.get('reason', 'Unknown')}"
            report += f"\n{'-' * 50}"

        report += "\n\n2. Network Connections"
        report += f"\n{'-' * 50}"
        
        for conn in self.suspicious_connections:
            report += f"\nIP: {conn['ip']}:{conn['port']}"
            report += f"\nDuration: {conn['duration']} seconds"
            report += f"\nReason: {conn['reason']}"
            report += f"\n{'-' * 50}"

        report += "\n\n3. Attacker IPs"
        report += f"\n{'-' * 50}"
        for ip in self.attacker_ips:
            report += f"\n{ip}"

        return report

def main():
    hunter = AdvancedMalwareHunter()
    print("Starting Advanced Malware Hunter...")
    
    # Effectuer un scan profond
    report = hunter.deep_scan()
    
    # Sauvegarder le rapport
    with open('advanced_malware_report.txt', 'w') as f:
        f.write(report)
    
    # Si des menaces sont détectées, proposer le nettoyage
    if hunter.suspicious_processes or hunter.attacker_ips:
        print("\n[!] Threats detected! Would you like to clean the infection? (y/n)")
        if input().lower() == 'y':
            hunter.clean_infection()
    
    print("\nScan completed. Report saved to 'advanced_malware_report.txt'")

if __name__ == "__main__":
    main()
